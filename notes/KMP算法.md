### 1、KMP相关概念

KMP主要应用在字符串匹配中，主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了**。

所以如何记录已经匹配的文本内容，是KMP的重点，也是next数组肩负的重任。

> 前缀表

前缀表用来**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀**。

next数组其本质就是一个前缀表(prefix table)，那么前缀表有什么作用呢？

**前缀表是用来回退的，它记录了模式串与主串（文本串）不匹配的时候，模式串应该从哪里开始重新匹配。**

> 最长公共前后缀

文中字符串的**前缀是指不包含最后一个字符串的所有以第一个字符开头的连续子串，后缀是指不包含第一个字符的所有以最后一个字符结尾的连续字串**。

这里的最长公共前后缀的长度其实也就是前缀表要求的相同前后缀的长度。

例如：aabaa的最长公共前后缀是aa，aaa的最长公共前后缀也是aa。



### 2、如何计算前缀表

以 aabaaf 为例讲解前缀表的计算过程：

- 长度为前1个字符的子串`a`，最长相同前后缀的长度为0。（前缀是不包括最后一个字符的子串而后缀是不包括第一个字符的子串）
- 长度为前2个字符的子串`aa`，最长相同前后缀的长度为1。
- 长度为前3个字符的子串`aab`，最长相同前后缀的长度为0。

- 长度为前4个字符的子串`aaba`，最长相同前后缀的长度为1。
- 长度为前5个字符的子串`aabaa`，最长相同前后缀的长度为2。
- 长度为前6个字符的子串`aabaaf`，最长相同前后缀的长度为0。

那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图：

![img](\pics\KMP精讲8.png)

可以看出模式串与前缀表对应位置的数字表示的就是：**下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**



### 3、构造next数组

**构造next数组其实就是计算模式串s，前缀表的过程。** 主要有如下三步：

1. 初始化
2. 处理前后缀不相同的情况
3. 处理前后缀相同的情况

接下来我们详解详解一下。

> 初始化

定义两个指针i和j：

- **j指向前缀待匹配的末尾位置，并且表示相同前后缀的长度**
- **i指向后缀起始位置**。

然后还要对next数组进行初始化赋值i，如下：

```java
int j = 0;	// 前缀待匹配的末尾位置
next[0] = j;	// 相同前后缀长度为0
```

> 处理前后缀不相同的情况

因为后缀末尾位置为0已经初始化，那么i从1开始，进行s[i] 与 s[j]的比较

所以遍历模式串s的循环下标i 要从 1开始，代码如下：

```
for(int i = 1; i < s.size(); i++) {...}
```

如果 s[i] 与 s[j]不相同，也就是遇到 前后缀末尾不相同的情况，就要向前回退。怎么回退呢？

**前缀表是用来回退的，它记录了模式串与主串（文本串）不匹配的时候，模式串应该从哪里开始重新匹配**

**前缀表是用来回退的，它记录了模式串与主串（文本串）不匹配的时候，模式串应该从哪里开始重新匹配**

**前缀表是用来回退的，它记录了模式串与主串（文本串）不匹配的时候，模式串应该从哪里开始重新匹配**

以字符串`aabaaf` 当i = 5为例，此时前缀`aa` 和后缀`bb` 已经匹配好了，长度为2，此时j也为2，指向即将匹配的字符b，而i指向的是字符f。这个过程需要不断从匹配好的相同前后缀中确定新的匹配位置。

开始j = 2中已匹配好的前后缀的 `aa` 后，此时待匹配前缀`aab` 与待匹配后缀`aaf` ，但s[j]不等于s[i]无法匹配；

则回退找匹配好的`aa` 的最长前后缀，即前缀为`a` 后缀为`a` ，前缀长度为j = 1，表示前缀待匹配的末尾位置为1，即新的待匹配前缀为`aa`，待匹配后缀为`af` , 此时s[j]不等于s[i]无法匹配;

则继续回退找匹配好的`a` 的最长前后缀，此时前后缀均为` ` ，且j=0，新的待匹配前缀为`a` 而后缀为`f`，说明是得从头开始匹配啦。

```java
while (j > 0 && s[i] != s[j]) {
    j = next[j - 1];
}
if (s[i] == s[j]) {
    j++;
}
next[i] = j;
```

> 处理前后缀相同的情况

如果s[i] 与 s[j] 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。

```java
if (s[i] == s[j]) {
    j++;
}
next[i] = j;
```

最后整体构建next数组的函数代码如下：

```java
void getNext(int* next, const string& s) {
    int j = 0;
    next[0] = 0;
    for(int i = 1; i < s.size(); i++) {
        while (j > 0 && s[i] != s[j]) {
            j = next[j - 1];
        }
        if (s[i] == s[j]) {
            j++;
        }
        next[i] = j;
    }
}
```

代码构造next数组的逻辑流程动画如下：

![KMP精讲3](\pics\KMP精讲3.gif)



### 4、使用next数组做匹配

```java
class Solution {
public:
    void getNext(int* next, const string& s) {
        int j = 0;
        next[0] = 0;
        for(int i = 1; i < s.size(); i++) {
            while (j > 0 && s[i] != s[j]) {
                j = next[j - 1];
            }
            if (s[i] == s[j]) {
                j++;
            }
            next[i] = j;
        }
    }
    int strStr(string haystack, string needle) {
        if (needle.size() == 0) {
            return 0;
        }
        int next[needle.size()];
        getNext(next, needle);
        int j = 0;
        for (int i = 0; i < haystack.size(); i++) {
            while(j > 0 && haystack[i] != needle[j]) {
                j = next[j - 1];
            }
            if (haystack[i] == needle[j]) {
                j++;
            }
            if (j == needle.size() ) {
                return (i - needle.size() + 1);
            }
        }
        return -1;
    }
};
```



























aabaaf

i是后缀末尾

j是前缀末尾，最长相等前后的长度

理解：走到aab时：开始的前缀串(j=1)是aa，后缀串(i=2)是ab，回退为(j=0)；前缀串(j=0)为a，后缀串(i=2)为b；next[i] = 0;

走到aaba时，前缀串(j=0)是a，后缀串(i=3)是a; j++, next[i] = 1;

走到aabaa时，前缀串(j=1)是aa，后缀串(i=3)是aa; next[i] = 1;

