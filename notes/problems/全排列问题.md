从n个不同元素中任取m（m≤n）个元素，按照一定的顺序排列起来，叫做从n个不同元素中取出m个元素的一个排列。当m=n时所有的排列情况叫全排列。

给定一组数，想要生成它的所有排列可以使用回溯算法，也可以通过字典序来实现。

使用字典序输出全排列的思路是，首先输出字典序最小的排列，然后输出字典序次小的排列，……，最后输出字典序最大的排列。这里就涉及到一个问题，对于一个已知排列，如何求出其字典序中的下一个排列。这里给出算法：

1. 对于排列a[1...n]，找到所有满足a[k]<a[k+1] (0<k<n-1)的k的最大值，如果这样的k不存在，则说明当前排列已经是a的所有排列中字典序最大者，所有排列输出完毕
2. 在a[k+1...n]中，寻找满足这样条件的元素l，使得在所有a[l]>a[k]的元素中，a[l]取得最小值，有重复时保证l是最靠后那个。也就是说a[l]>a[k]，但是小于所有其他大于a[k]的元素
3. 交换a[l]与a[k]
4. 对于a[k+1...n]，反转该区间内元素的顺序。也就是说a[k+1]与a[n]交换，a[k+2]与a[n-1]交换，……，这样就得到了a[1...n]在字典序中的下一个排列

以arr=[1, 7, 6, 3, 5, 4, 2]举个例子，现在找到递增的最后位置k = 3（即[1, 7, 6, **3**, 5, 4, 2]），接着找到后面大于arr[k] = 3中最靠后的，得l = 5（arr[l] = 4）,交换arr[l]和arr[k]得到arr = [1, 7, 6, 4, 5, 3, 2]，接着转置后半段，得到arr = [1, 7, 6, 4, 2, 3, 5]。

**算法实现**

```java
public void nextPermutation(int[] nums) {
    // 第一步，寻找 k
    int k = -1;
    for (int i = 0; i < nums.length - 1; i++) {
        if (nums[i] < nums[i + 1]) {
            k = i;
        }
    }
    if (k == -1) {
        Arrays.sort(nums);
        return;
    }
    // 第二步，寻找 l
    int l = k + 1;
    for (int i = k + 2; i < nums.length; i++) {
        if (nums[i] > nums[k] && nums[i] <= nums[l]) {
            l = i;
        }
    }
    // 第三步，交换a[l]与a[k]
    int tmp = nums[k];
    nums[k] = nums[l];
    nums[l] = tmp;
    // 第四步，对于a[k+1...n]，反转该区间内元素的顺序
    for (int i = k + 1, j = nums.length - 1; i < j; i++, j--) {
        tmp = nums[i];
        nums[i] = nums[j];
        nums[j] = tmp;
    }
    return;
}
```

