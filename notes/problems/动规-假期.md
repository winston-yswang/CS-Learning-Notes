## 假期

[#链接](https://www.nowcoder.com/questionTerminal/7cd9a140387e455a972e8fea0e74be2c)：由于业绩优秀，公司给小Q放了 n 天的假，身为工作狂的小Q打算在在假期中工作、锻炼或者休息。他有个奇怪的习惯：不会连续两天工作或锻炼。只有当公司营业时，小Q才能去工作，只有当健身房营业时，小Q才能去健身，小Q一天只能干一件事。给出假期中公司，健身房的营业情况，求小Q最少需要休息几天。

```shell
# 输入：放假天数，公司和健身的营业情况
4
1 1 0 0
0 1 1 0

# 输出：休息的最少天数
2
```



## 思路

这类题目很明确是一道动规题目，那么话不多说，直接按动规路子走起吧。

（1）**确定dp数组以及下标含义**

这题的状态其实还是容易想到的分别是工作、锻炼和休息，并且三个状态之间还存在时间上的关联性。因此设dp[i][0] 、dp[i][1]、dp[i][2] 分别表示第i处于工作、健身、休息的情况下，累计休息的最小天数。

（2）**确定递推公式**

因为这题目确实三个状态，且每个状态的变化又与前一时刻的状态有关，为了方便分析，引入状态机的概念让题目简单清晰。

![image-20220110145654045](..\pics\状态机-假期.png)

从图中，我们可以知道若第i天要进入工作时，那么第i-1天只能是休息或健身状态；若第i天要进入健身状态，那么第i-1天只能是工作或休息状态；而若第i天打算休息，那么第i-1可以是任意状态。

状态转移方程：

- 工作：dp[i][0] = min(dp[i - 1][1], dp[i - 1][2])
- 健身：dp[i][1] = min(dp[i - 1][0], dp[i - 1][2])
- 休息：dp[i][2] = min(dp[i - 1][0], dp[i - 1][1], dp[i - 1][2]) + 1

（3）**初始化**

这里其实还存在一个问题：当第i天计划去工作或者健身，但是恰巧遇上不营业怎么办？

我认为**该情况算一种变相的休息，故应该在前一天的休息天数基础上加1。**

```java
int[][] dp = new int[n + 1][3];

if (work[i] == 1) { // 第i天可以工作
    dp[i][0] = Math.min(dp[i - 1][1], dp[i - 1][2]);
} else {
    dp[i][0] = dp[i - 1][0] + 1;
}
if (gym[i] == 1) {  // 第i天可以健身
    dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][2]);
} else {
    dp[i][1] = dp[i - 1][1] + 1;
}
```

在此给出完整代码：

```java
public int minRelexDays() {
    Scanner in = new Scanner(System.in);
    int n = in.nextInt();
    int[] work = new int[n + 1];
    int[] gym = new int[n + 1];

    for (int i = 1; i <= n; i++) {
        work[i] = in.nextInt();
    }
    for (int i = 1; i <= n; i++) {
        gym[i] = in.nextInt();
    }

    int[][] dp = new int[n + 1][3]; // 表示第i天工作、健身或休息的话前i天的最小休息天数

    for (int i = 1; i <= n; i++) {
        if (work[i] == 1) { // 第i天可以工作
            dp[i][0] = Math.min(dp[i - 1][1], dp[i - 1][2]);
        } else {
            dp[i][0] = dp[i - 1][0] + 1;
        }
        if (gym[i] == 1) {  // 第i天可以健身
            dp[i][1] = Math.min(dp[i - 1][0], dp[i - 1][2]);
        } else {
            dp[i][1] = dp[i - 1][1] + 1;
        }
        // 休息
        dp[i][2] = Math.min(dp[i - 1][0], Math.min(dp[i - 1][1], dp[i - 1][2])) + 1;    
    }

    return Math.min(dp[n][0], Math.min(dp[n][1], dp[n][2]));
}
```

看完上述代码，可以明白本题的难点在于如何解释当天不营业时的状态。另一种较好理解的角度是去计算不休息的天数，最后的结果用总时间减去最大的不休息天数，得到最小的休息天数。

