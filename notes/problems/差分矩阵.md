### 1、题目描述

输入一个n行m列的整数矩阵，再输入q个操作，每个操作包含五个整数x1, y1, x2, y2, c，其中(x1, y1)和(x2, y2)表示一个子矩阵的左上角坐标和右下角坐标。

每个操作都要将选中的子矩阵中的每个元素的值加上c。

请你将进行完所有操作后的矩阵输出。

**输入格式**
第一行包含整数n,m,q。

接下来n行，每行包含m个整数，表示整数矩阵。

接下来q行，每行包含5个整数x1, y1, x2, y2, c，表示一个操作。

```txt
3 4 3
1 2 2 1
3 2 2 1
1 1 1 1
1 1 2 2 1
1 3 2 3 2
3 1 3 4 1
```

**输出格式**
共 n 行，每行 m 个整数，表示所有操作进行完毕后的最终矩阵。

```txt
2 3 4 1
4 3 4 1
2 2 2 2
```

数据范围
1 ≤ n , m ≤ 1000 , 1≤n,m≤1000,1≤n,m≤1000,
1 ≤ q ≤ 100000 , 1≤q≤100000,1≤q≤100000,
1 ≤ x 1 ≤ x 2 ≤ n , 1≤x1≤x2≤n,1≤x1≤x2≤n,
1 ≤ y 1 ≤ y 2 ≤ m , 1≤y1≤y2≤m,1≤y1≤y2≤m,
− 1000 ≤ c ≤ 1000 , −1000≤c≤1000,−1000≤c≤1000,
− 1000 ≤ 矩 阵 内 元 素 的 值 ≤ 1000 −1000≤矩阵内元素的值≤1000−1000≤矩阵内元素的值≤1000

### 2、思路和实现

> 一维差分

差分可以看作是前缀和的逆运算，同前缀和一样，差分从1号位置点开始，假设我们有原数组a: a[1], a[2], a[3] ... a[i]，我们需要构造数组b：b[1], b[2], b[3] ... b[i]，使得 **a[i] = b[1] + b[2] + b[3] + ... + b[i]，即数组a是数组b的前缀和**，即每个 a[i] 都可以对b数组从 1 ~ i 求前缀和得到。

```txt
a[0] = 0;
b[1] = a[1] - a[0];
b[2] = a[2] - a[1];
...
b[i] = a[i] - a[i - 1]
```

对于这么一种情况，我们可以利用差分数组来快速解题：**将数组a的[l, r]这一区间内加上一个常数c**，最暴力的做法：利用for循环遍历a数组，并在[l, r]区间内加上c，如果有m次操作，这样下来的时间复杂度为O(n * m)，差分则是对这一步骤的优化。

我们要将一个数列a的[l, r]范围内加上（或减去）一个数c，可对a的差分数组b进行如下操作：

```java
b[l] += c, b[r + 1] -= c;
```

> 二维差分

对差分矩阵中下标为 (i, j) 的元素加上 d 等价于对原矩阵中，以 (i, j) 为左上角， 以 (n, m) 为右下角的区块每个值都加上 d。如下图所示：

![image-20211206102932920](C:\Users\Lenovo\Desktop\笔记\CS-Learning-Notes\notes\pics\image-20211206102932920.png)

对于一个给定的矩阵A，它的差分矩阵B中$B_{i,j}$ 可用如下计算公式：
$$
B_{j,j} = A_{i,j} - A_{i-1, j} - A_{i, j-1} + A_{i - 1, j -1} {\quad}(1\leq i \leq n)
$$
实际上，上面的公式更像是通过**原矩阵是差分矩阵的前缀和**这个条件推导出来的。

**二维差分主要是用于快速将一个区块内所有元素都加上d**，因为原矩阵A是差分矩阵B的前缀和，假设把B中(x, y) 下标的点加上那么算前缀和时，只要经过该点，那前缀和都会 +d。所以想要在指定区块 +d，只要把右边和下边部分的+d效果去除就可以实现了。

![image-20211206104351123](..\pics\image-20211206104351123.png)

对A矩阵中蓝色区块每个元素都加上d的操作等价于进行下面的四个操作：
$$
B[x_{1},y_{1}] \; += d \\
B[x_{2}+1, y_{1}] \; -= d \\
B[x_{1}, y_{2} + 1] \; -= d \\
B[x_{2}+1, y_{2}+1] \; += d
$$

> 代码实现

```java
public static void main(String[] args) {
    Scanner scanner = new Scanner(System.in);
    int n = scanner.nextInt();
    int m = scanner.nextInt();
    int q = scanner.nextInt();
    int[][] A = new int[n + 2][m + 2];  // 为了程序的简洁性，需要在原数据矩阵外包一层
    int[][] B = new int[n + 2][m + 2];

    // 构建二维差分矩阵
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            A[i][j] = scanner.nextInt();
            insert(B, i, j , i, j, A[i][j]);
        }
    }

    // 执行操作修改差分矩阵
    while (q-- > 0) {
        int x1 = scanner.nextInt(), y1 = scanner.nextInt();
        int x2 = scanner.nextInt(), y2 = scanner.nextInt();
        int val = scanner.nextInt();
        insert(B, x1, y1, x2, y2, val);
    }
    // 求前缀和得到结果矩阵
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            B[i][j] += B[i - 1][j] + B[i][j - 1] - B[i - 1][j - 1];
        }
    }
    System.out.println("ok");

}

public static void insert(int[][] B, int x1, int y1, int x2, int y2, int val) {
    B[x1][y1] += val;
    B[x1][y2 + 1] -= val;
    B[x2 + 1][y1] -= val;
    B[x2 + 1][y2 + 1] += val;
}
```

