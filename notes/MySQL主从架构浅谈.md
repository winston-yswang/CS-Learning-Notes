### 1、为什么需要主从架构？

绝大多数影响性能的问题出现在数据库资源是有限的，而不是应用节点。当数据库的读写性能发生瓶颈时，就需要考虑优化整体架构了。可以采用的方式有：

#### 垂直切分

业务上的垂直拆分，将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。

#### 读写分离

对数据库程序涉及到读和写的操作，且绝大多数是写多读少，这就引出了读写分离以及MySQL的主从架构。



### 2、MySQL主从复制

#### 异步复制

一个主库，一个或多个从库，数据**异步同步**到从库。[#参考文章](https://juejin.cn/post/6967224081410162696)

这种模式下，主节点**不会主动推送数据**到从节点，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理。

这样就会有一个问题，主节点如果崩溃掉了，此时主节点上已经提交的事务可能并没有传到从节点上，如果此时，强行将从提升为主，可能导致新主节点上的数据不完整。

#### 同步复制

在 MySQL cluster 中特有的复制方式。

当主库执行完一个事务，然后所有的从库都复制了该事务并**成功执行完**才返回成功信息给客户端。

因为需要等待所有从库执行完该事务才能返回成功信息，所以全同步复制的性能必然会收到严重的影响。

#### 半同步复制

在异步复制的基础上，确保任何一个主库上的事物在提交之前**至少有一个从库**已经收到该事物并日志记录下来。

介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待**至少一个从库接收到并写到** relay log 中才返回成功信息给客户端(只能保证主库的 Binlog 至少传输到了一个从节点上)，否则需要等待直到**超时时间**然后切换成异步模式再提交。

相对于异步复制，半同步复制提高了数据的**安全性**，一定程度的保证了数据能成功备份到从库，同时它也造成了一定程度的延迟，但是比全同步模式延迟要低，这个延迟最少是一个 TCP/IP 往返的时间。所以，半同步复制最好在**低延时**的网络中使用。

半同步模式不是 MySQL 内置的，从 `MySQL 5.5` 开始集成，需要 master 和 slave 安装插件开启半同步模式。



### 3、MySQL主从同步机制

MYSQL 主从同步是在 MySQL 主从复制（Master-Slave Replication）基础上实现的，主要涉及三个线程：binlog 线程、I/O 线程和 SQL 线程。

- **binlog 线程** ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
- **I/O 线程** ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（Relay log）。
- **SQL 线程** ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（Replay）。

![主从同步](pics\主从同步.png)

主从架构下的更新操作流程：

![主从架构更新](pics\主从架构更新.png)

当 Master 收到一条客户端的更新操作后，其大致的执行流程如下：[#参考文章](https://blog.csdn.net/weixin_34452850/article/details/108304528?utm_medium=distribute.pc_category.none-task-blog-hot-10.nonecase&depth_1-utm_source=distribute.pc_category.none-task-blog-hot-10.nonecase&request_id=)

1. 从库生成**两个线程**，一个 I/O 线程，一个 SQL 线程；
2. I/O 线程去请求主库的 binlog，并将得到的 binlog 日志**写到** relay log(中继日志) 文件中；
3. 主库会**生成**一个 log dump 线程，用来给从库 I/O 线程传 binlog；
4. SQL 线程会读取 relay log 文件中的日志，并**解析**成具体操作，来实现主从的操作一致，而最终数据一致；



### 4、主从同步机制存在弊端

#### 一致性问题

正常情况下，只要主库执行更新生成的所有 binlog，都可以传到备库并被正确地执行，备库就能达到跟主库一致的状态，这就是最终一致性。但是，MySQL 要提供高可用能力，只有最终一致性是不够的，这有可能导致出现脏读的情境。

#### 主从延迟

在主从同步的过程中，有3个比较重要的时间点：

1. Master 执行完成一个事务，写入 binlog，这个时刻记为 T1；
2. Master 将 binlog 发送给 Slave ，Slave 接收完这个 binlog 的时刻记为 T2；
3. Slave 执行完成这个事务，这个时刻记为 T3。

**所谓主从同步延迟，就是同一个事务，在备库执行完成的时间和主库执行完成的时间之间的差值，也就是上面的 T3-T1。**

在网络正常的时候，日志从 Master 传给 Slave 所需的时间是很短的，即 T2-T1 的值是非常小的。也就是说，网络正常情况下，主从延迟的主要来源是 Slave 接收完 binlog 和执行完这个事务之间的时间差。

所以说，主从同步延迟最直接的表现是，Slave 消费中转日志（relay log）的速度，比 Master 生产 binlog 的速度要慢。下面我们来分析下，主从同步延迟的产生原因有以下情况：

1. Slave 所在的机器性能比 Master 差

   在生产环境下，建议所以主库和从库都选用相同规格的机器，并且做对称部署，因为主备可能发生切换，Slave 随时可能切换成 Master。

2. Slave 的查询压力过大

   如果 Slave 承担了过多的查询、分析类请求，就可能耗费大量的 CPU 资源，影响数据同步速度，进而造成主从同步延迟。

   针对这种情况，可以考虑采用一主多从架构，让多个从库来共同分担读请求的压力。

3. 大事务

   如果一个大事务在主库上执行了 10 分钟，那这个事务很可能就会导致主从延迟 10 分钟。因此应该尽量避免大事务操作，比如一次删除大量的数据，或者大表的 DDL 等。

### 5、主从同步的循环复制问题

在我们真实的开发场景中，往往主库不会一直是主库，从库不会一直是从库。为了保证安全性。往往是这样设计的。

![image-20220129222124807](pics\image-20220129222124807.png)

这样的就会出现另一个问题。业务逻辑在节点 A 上更新了一条语句，然后再把生成的 binlog 发给节点 B，节点 B 执行完这条更新语句后也会生成 binlog。（我建议你把参数 log_slave_updates 设置为 on，表示备库执行 relay log 后生成 binlog）。

那么，如果节点 A 同时是节点 B 的备库，相当于又把节点 B 新生成的 binlog 拿过来执行了一次，然后节点 A 和 B 间，会不断地循环执行这个更新语句，也就是循环复制了。这个要怎么解决呢？

**解决方案：**

1. 规定两个库的 server id 必须不同，如果相同，则它们之间不能设定为主备关系；
2. 一个备库接到 binlog 并在重放的过程中，生成与原 binlog 的 server id 相同的新的 binlog；
3. 每个库在收到从自己的主库发过来的日志后，先判断 server id，如果跟自己的相同，表示这个日志是自己生成的，就直接丢弃这个日志。

按照这个逻辑，如果我们设置了双 M 结构，日志的执行流就会变成这样：

1. 从节点 A 更新的事务，binlog 里面记的都是 A 的 server id；
2. 传到节点 B 执行一次以后，节点 B 生成的 binlog 的 server id 也是 A 的 server id；
3. 再传回给节点 A，A 判断到这个 server id 与自己的相同，就不会再处理这个日志。所以，死循环在这里就断掉了。

