#### 1、操作系统的组成部分

![image-20211124211925735](pics\image-20211124211925735.png)



#### 2、计算机插上电源操作系统做了什么

1. 加电––––打开电源开关，给主板和内部风扇供电。 
2. 启动引导程序––––CPU开始执行存储在ROM BIOS中的指令。 
3. 开机自检––––计算机对系统的主要部件进行诊断测试。 
4. 加载操作系统––––计算机将操作系统文件从磁盘读到内存中。 
5. 检查配置文件，定制操作系统的运行环境––––读取配置文件，根据用户的设置对操作系统进行定制。 
6. 准备读取命令和数据––––计算机等待用户输入命令和数据。 

参考文章：[计算机通电后的基本操作](https://blog.csdn.net/ai_yue/article/details/82958153)



#### 3、固态硬盘和机械硬盘区别

机械硬盘的原理类似于光盘，主要结构是一个高速旋转的盘片的和在盘片上来回读写数据的磁头。而固态硬盘则是以电子存储的方式来储存数据的，主要由主控芯片、闪存芯片、固件算法等组成，和我们平常使用的U盘类似，不过比U盘使用的闪存芯片更多。



#### 4、程序编译的过程

应用程序从用户编写的源文件到内存中执行的进程，大致分为了一下几个阶段：首先编译程序将源代码编译成了多个目标模块，其次通过链接程序将编译好的目标模块，以及所需要的一些库函数链接在一起，形成了完整的装入模块，再通过装入程序将这些装入模块装入内存并执行。

参考文章：[程序编译过程](https://blog.csdn.net/qq_34402394/article/details/88650664)



#### 5、用户态和内核态

由于需要限制不同的程序之间的访问能力, 防止他们获取别的程序的内存数据, 或者获取外围设备的数据, 并发送到网络, CPU划分出两个权限等级 -- 用户态和内核态。

内核态：cpu可以访问内存的所有数据，包括外围设备，例如硬盘，网卡，cpu也可以将自己从一个程序切换到另一个程序。

用户态：只能受限的访问内存，且不允许访问外围设备，占用cpu的能力被剥夺，cpu资源可以被其他程序获取。

用户态切换到内核态的方式：系统调用、异常、中断



#### 6、线程和进程的区别、有了进程为什么需要线程

1. 进程就是程序在某个数据集合上的一次执行过程，
2. 线程是进程的一个实体, 是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源。
3. 一个线程可以创建和撤销另一个线程，同一个进程中的多个线程之间可以并发执行。

由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，需要较大的时空开销，限制了并发程度的进一步提高。为减少进程切换的开销，把进程作为资源分配单位和调度单位这两个属性分开处理，即进程还是作为资源分配的基本单位，但是不作为调度的基本单位（很少调度或切换），把调度执行与切换的责任交给线程，即线程成为独立调度的基本单位，它比进程更容易（更快）创建，也更容易撤销。

补充：

线程的优点：一个进程中可以同时存在多个线程，这些线程共享该进程的资源。线程间的并发比进程的开销更小，系统并发性提升。

线程的缺点：当进程中的一个线程奔溃时，会导致其所属进程的所有线程奔溃。

进程主要由PCB、数据段和程序段三个部分组成，其中PCB 是提供给操作系统用的，而程序段、数据段是给进程自己用的。

进程的状态：运行态、就绪态、阻塞态、新建态和终止态

![20210219155101](pics\20210219155101.png)

参考文章：[有了进程为什么还要线程？ ](https://www.cnblogs.com/Berryxiong/p/6429723.html)



#### 7、讲一下基本分段管理和基本分页管理（物理内存管理）

内存管理的任务就是有效地管理内存，即记录哪些内存是正确使用的，哪些内存是空闲的，在进程需要时为其分配内存，在进程使用完后释放内存。

**连续分配管理方式**

单一连续分配：内存中只能有一道用户程序，用户程序独占整个用户区空间；

固定分区分配：将整个用户空间划分为若干个固定大小的分区，在每个分区中只装入一道作业；

动态分区分配：使用特殊的数据结构记录内存的使用情况，根据进程的大小动态地建立分区。

存在的问题：由于其要求把作业（进程）放在内存的一片连续区域中，很容易出现大段的连续内存空间因为不足够容纳作业或进程而不可用。

**非连续分配管理方式**

基本分页管理：将内存空间分为一个个大小相等的分区，每个分区就称为一个 “页框（page frame）”。每个页框有一个编号，即“页框号”（也成为物理页框号、内存块号），页框号从 0 开 始 。

进程的页面与内存的页框有一一对应的关系。 各个页面不必连续存放，可以放到不相邻（离散）的各个页框中。

一个进程对应一张页表，进程的每个页面对应一个页表项，每个页表项由页号和块号（页框号）组成，记录着进程页面和实际存放的内存块之间的映射关系。

在任何分页式系统中，都不可避免地要考虑下面这两个问题：

问题 1：如何保证虚拟地址到物理地址的转换足够快 — 使用快表解决

问题 2：如何解决虚拟地址空间大，页表也会很大的问题（页表项多了，页表自然也就大了）— 使用多级页表解决

基本分段管理：段式系统是按照用户作业（进程）中的自然段来划分逻辑空间的。段与段之间可以不连续存储，但是段的内部仍然是连续的。和基本分页管理一样，基本分段管理也需要一个数据结构来记录虚拟地址和物理地址之间的映射，这个数据结构就是段表。

基本段页管理：对虚拟地址空间先进行段的划分，然后在每一段内再进行页的划分。

参考文章：[内存管理](https://flying-veal.notion.site/c3b6152461454dde89aa5239ea15d00c)



#### 8、讲一下请求分段管理和请求分页管理（虚拟内存管理）、什么是虚拟内存、虚拟内存的实现

为了解决内存不足的情况，缓和大程序与小内存之间的矛盾，扩充内存容量势在必行。

对内存的逻辑扩充技术主要有三种：覆盖技术、交换技术、以及虚拟内存（Virtual Memory），也称为虚拟存储器。事实上，这些逻辑扩充技术的核心理念都是一致的，研究的都是将哪个进程（或进程的某部分）暂时从内存移到外存（磁盘），以腾出内存空间供其他进程（或进程的某部分）占用。

虚拟内存技术基于一个非常重要的原理，**局部性原理**：

1）**时间局部性**：如果执行了程序中的某条指令，那么不久后这条指令很有可能再次执行；如果某个数据被访问过，不久之后该数据很可能再次被访问。（因为程序中存在大量的循环）

2）**空间局部性**：一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也很有可能被访问（因为很多数据在内存中都是连续存放的，并且程序的指令也是顺序地在内存中存放的）

基于这个局部性原理，在一个程序装入内存的时候，可以只将这个程序中很快会用到的部分装入内存，暂时用不到的部分仍然留在外存（磁盘），并且程序可以正常执行；

而在程序执行过程中，当 CPU 所需要的信息不在内存中的时候，由操作系统负责将所需信息从外存（磁盘）调入内存，然后继续执行程序；

如果调入内存的时候内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存。

以上，就是虚拟内存技术。

传统的基本分页管理、基本分段管理、基本段页式管理和虚拟内存技术结合，分别称为请求分页管理（页式虚存系统）、请求分段管理（段式虚存系统）、请求段页式管理（段页式虚存系统）

以请求调页和页面置换为例：

- 在程序执行过程中，当所访问的信息不在内存时，由操作系统负责将所需信息从外存（磁盘）调入内存，然后继续执行程序（操作系统要提供请求调页的功能， 将内存中缺失的页面从磁盘调入内存 ）；
- 若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到磁盘（操作系统要提供页面置换的功能， 将暂时用不到的页面换出磁盘）。



#### 9、零拷贝（这个最好还要讲下 Java 是如何实现的）

零拷贝主要的任务就是**避免**CPU将数据从一块存储拷贝到另外一块存储，主要就是利用各种零拷贝技术，避免让CPU做大量的数据拷贝任务，减少不必要的拷贝，或者让别的组件来做这一类简单的数据传输任务，让CPU解脱出来专注于别的任务。这样就可以让系统资源的利用更加有效。

![img](pics\format.png)



#### 10、IO 复用模型了解哪些，select/poll/epoll 分别讲讲

Unix 有五种 I/O 模型：

**阻塞式 I/O**：当应用发起读取数据申请时，在内核数据没有准备好之前，应用进程会被阻塞，直到数据从内核缓冲区复制到应用进程缓冲区中才返回。

**非阻塞式 I/O**：在应用调用recvfrom读取数据时，如果该缓冲区没有数据的话，内核就会直接返回一个错误码，不会让应用一直等待中。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为轮询（polling）。

**IO多路复用**：如果一个 Web 服务器没有 I/O 复用，那么每一个 Socket 连接都需要创建一个线程去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，I/O 复用不需要进程线程创建和切换的开销，系统开销更小。

有人就提出了一个思路，能不能提供一种方式，可以由一个线程监控多个网络请求（我们后面将称为fd文件描述符，linux系统把所有网络请求以一个fd来标识），这样就可以只需要一个或几个线程就可以完成数据状态询问的操作，当有数据准备就绪之后再分配对应的线程去读取数据，这么做就可以节省出大量的线程资源出来，这个就是IO复用模型的思路。

IO复用模型的思路就是系统提供了一种函数可以同时监控多个fd的操作，这个函数就是我们常说到的select、poll、epoll函数，有了这个函数后，应用线程通过调用select函数就可以同时监控多个fd，select函数监控的fd中只要有任何一个数据状态准备就绪了，select函数就会返回可读状态，这时询问线程再去通知处理数据的线程，对应线程此时再发起recvfrom请求去读取数据。

**信号驱动IO模型**：IO复用模型里面的select虽然可以监控多个fd了，但select其实现的本质上还是通过不断的轮询fd来监控数据状态， 因为大部分轮询请求其实都是无效的，所以信号驱动IO意在通过这种建立信号关联的方式，实现了发出请求后只需要等待数据就绪的通知即可，这样就可以避免大量无效的数据状态轮询操作。

**异步IO**：异步IO的优化思路是解决了应用程序需要先后发送询问请求、发送接收数据请求两个阶段的模式，在异步IO的模式下，只需要向内核发送一次请求就可以完成状态询问和数拷贝的所有操作。

**阻塞与非阻塞**：所谓阻塞就是发起读取数据请求的时，当数据还没准备就绪的时候，这时请求是即刻返回，还是在这里等待数据的就绪，如果需要等待的话就是阻塞，反之如果即刻返回就是非阻塞。

**同步与异步**：在IO模型里面如果请求方从发起请求到数据最后完成的这一段过程中都需要自己参与，那么这种我们称为同步请求；反之，如果应用发送完指令后就不再参与过程了，只需要等待最终完成结果的通知，那么这就属于异步。

**同步阻塞与同步非阻塞**：两者不同的只是发起读取请求的时候一个请求阻塞，一个请求不阻塞，但是相同的是，他们都需要应用自己监控整个数据完成的过程。

I/O 复用：

select/poll/epoll 都是 I/O 多路复用的具体实现，select 出现的最早，之后是 poll，再是 epoll。

select：select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据 可读、可写、或者有except），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以通过遍历fdset，来找到就绪的描述符。

select的缺陷：1、单个进程所打开的FD是有一定限制的，它由FD_SETSIZE设置，默认值是1024。2、对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低。

poll：poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。

它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。2、poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。

epoll：epoll支持水平触发和边缘触发，最大的特点在于边缘触发，它只告诉进程哪些fd刚刚变为就绪态，并且只会通知一次。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。

epoll对文件描述符的操作有两种模式：LT（level trigger）和ET（edge trigger）。LT模式是默认模式，LT模式与ET模式的区别如下：

LT模式：当 epoll_wait() 检测到描述符事件到达时，将此事件通知进程，进程可以不立即处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。

ET模式：和 LT 模式不同的是，通知之后进程必须立即处理事件，下次再调用 epoll_wait() 时不会再得到事件到达的通知。很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

参考文章：[Socket](https://github.com/CyC2018/CS-Notes/blob/master/notes/Socket.md) 、[100%弄明白5种IO模型](https://zhuanlan.zhihu.com/p/115912936) 、[IO复用模型](https://www.cnblogs.com/mingaixin/p/5432716.html)、[epoll](https://zhuanlan.zhihu.com/p/358208161)





