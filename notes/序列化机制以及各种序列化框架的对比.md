## 1、序列化

为什么需要序列化？

**序列化主要是为了方便持久化或数据传输。**序列化机制能够将一个实例对象信息写入到一个字节流中（**只序列化对象的属性值，而不会去序列化方法**），序列化后的对象可用于网络传输，或者持久化到数据库、磁盘中。反序列化机制则是在需要对象的时候，再通过字节流中的信息来重构一个相同的对象。

在高并发系统中，序列化的速度快慢，会影响请求的响应时间，序列化后的传输数据体积大，会导致网络吞吐量下降，所以，一个优秀的序列化框架可以提高系统的整体性能。



## 2、Java序列化

JDK 提供的两个输入、输出流对象 **ObjectInputStream** 和 **ObjectOutputStream**，它们只能对实现了 Serializable 接口的类的对象进行反序列化和序列化。

之所以采用接口的形式，是因为序列化会对性能有影响，只对需要序列化的对象进行序列化,而其他的对象默认是不序列化的。

### 2.1 可选的自定义序列化

1. 有时某些属性不需要序列化，**可以使用transient关键字选择不需要序列化的字段。**使用transient修饰的属性，java序列化时，会忽略掉此字段，所以反序列化出的对象，被transient修饰的属性是默认值。对于引用类型，值是null；基本类型，值是0；boolean类型，值是false。
2. 使用transient虽然简单，但将此属性完全隔离在了序列化之外。java具体实现序列化的是**writeObject**和**readObject**，通常这两个方法是默认的，我们也可以在实现Serializable接口的类中对其重写，定制属于自己的序列化和反序列化机制

```java
private void writeObject(java.io.ObjectOutputStream out) throws IOException；private void readObject(java.io.ObjectIutputStream in) throws IOException,ClassNotFoundException;
private void readObjectNoData() throws ObjectStreamException;
```

### 2.2 序列化版本号serialVersionUID

Java的序列化机制是通过在运行时判断类的`serialVersionUID` 来验证版本一致性的。显式地定义`serialVersionUID` 有两种用途：

1. 在某些场合，希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有相同的`serialVersionUID`；在某些场合，不希望类的不同版本对序列化兼容，因此需要确保类的不同版本具有不同的`serialVersionUID`。
2. 当你序列化了一个类实例后，希望更改一个字段或添加一个字段，不设置`serialVersionUID`，所做的任何更改都将导致无法反序化旧有实例，并在反序列化时抛出一个异常。如果你添加了serialVersionUID，在反序列旧有实例时，新添加或更改的字段值将设为初始化值（对象为null，基本类型为相应的初始默认值），字段被删除将不设置。

### 2.3 Java序列化缺陷

常用的RPC框架中，基本不使用JDK提供的序列化，主要JDK默认的序列化存在如下缺陷：[#参考文章](https://juejin.cn/post/6890958788719804429)

1. **无法跨语言**：在复杂系统中多是采用多种语言来编码的；
2. **易被攻击**：调用`readObject()` 进行反序列化时，它可以将几乎所有实现了 Serializable 接口的对象都实例化，即该方法可以执行任意类型的代码，可被攻击；
3. **序列化后的二进制流大**：Java 序列后的流会变大，最终会影响到系统的吞吐量；
4. **序列化性能太差**：序列化速度慢，影响网络通信的效率。



## 3、ProtoBuf序列化

### 3.1 Protocol Buffers存储格式

Protocol Buffers 是一种轻便高效的结构化数据存储格式。它使用 **T-L-V（标识 - 长度 - 字段值）的数据格式来存储数据**。

- T 代表字段的正数序列 (tag)，Protocol Buffers 将对象中的每个字段和正数序列对应起来，对应关系的信息是由生成的代码来保证的。在序列化的时候用整数值来代替字段名称，于是传输流量就可以大幅缩减；

- L 代表 Value 的字节长度，一般也只占一个字节；

- V 则代表字段值经过编码后的值。这种数据格式不需要分隔符，也不需要空格，同时减少了冗余字段名。

Protobuf 定义了一套自己的编码方式，几乎可以映射 Java/Python 等语言的所有基础数据类型。不同的编码方式对应不同的数据类型，还能采用不同的存储格式。
![protobuf](C:\Users\Lenovo\Desktop\笔记\CS-Learning-Notes\notes\pics\protobuf.jpg)

对于存储 Varint 编码数据，由于数据占用的存储空间是固定的，就不需要存储字节长度 Length，所以实际上 Protocol Buffers 的存储方式是 T - V，这样就又减少了一个字节的存储空间。

Protobuf 定义的 Varint 编码方式是一种变长的编码方式，每个字节的最后一位 (即最高位) 是一个标志位 (msb)，用 0 和 1 来表示，0 表示当前字节已经是最后一个字节，1 表示这个数字后面还有一个字节。

对于 int32 类型数字，一般需要 4 个字节表示，若采用 Varint 编码方式，对于很小的 int32 类型数字，就可以用 1 个字节来表示。对于大部分整数类型数据来说，一般都是小于 256，所以这种操作可以起到很好地压缩数据的效果。

我们知道 int32 代表正负数，所以一般最后一位是用来表示正负值，现在 Varint 编码方式将最后一位用作了标志位，那还如何去表示正负整数呢？如果使用 int32/int64 表示负数就需要多个字节来表示，在 Varint 编码类型中，通过 Zigzag 编码进行转换，将负数转换成无符号数，再采用 sint32/sint64 来表示负数，这样就可以大大地减少编码后的字节数。

### 3.2 ProtoBuf序列化的有点

1. 效率高
2. 支持跨平台和多语言
3. 扩展性和兼容性好
4. 使用简单

其中效率高是因为从序列化后的数据体积角度，与XML、JSON这类文本协议相比，ProtoBuf通过T-(L)-V（TAG-LENGTH-VALUE）方式编码，不需要", {, }, :等分隔符来结构化信息，同时在编码层面使用varint压缩，所以描述同样的信息，ProtoBuf序列化后的体积要小很多，在网络中传输消耗的网络流量更少，进而对于网络资源紧张、性能要求非常高的场景，ProtoBuf协议是不错的选择。[#参考文章](https://juejin.cn/post/6924841883545894919)

```java
// 我们简单做个对比
// 要描述如下JSON数据
{"id":1,"firstName":"Chris","lastName":"Richardson","email":[{"type":"PROFESSIONAL","email":"crichardson@email.com"}]}
# 使用JSON序列化后的数据大小为118byte
7b226964223a312c2266697273744e616d65223a224368726973222c226c6173744e616d65223a2252696368617264736f6e222c22656d61696c223a5b7b2274797065223a2250524f46455353494f4e414c222c22656d61696c223a226372696368617264736f6e40656d61696c2e636f6d227d5d7d
# 而使用ProtoBuf序列化后的数据大小为48byte
0801120543687269731a0a52696368617264736f6e2a190a156372696368617264736f6e40656d61696c2e636f6d1001
```

### 3.3 ProtoBuf的缺点

**可读性差，缺乏自描述**

XML，JSON是自描述的，而ProtoBuf则不是。

ProtoBuf是二进制协议，编码后的数据可读性差，如果没有idl文件，就无法理解二进制数据流，对调试不友好。

