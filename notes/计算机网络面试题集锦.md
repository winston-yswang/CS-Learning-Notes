#### 1、TCP为什么是三次握手？

三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常

第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常

第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常

所以三次握手就能确认双发收发功能都正常，缺一不可。



#### 2、TCP为什么是四次挥手

因为TCP是全双工通信的：

   （1）第一次挥手

​     当主动方发送断开连接的请求（即FIN报文）给被动方时，仅仅代表主动方不会再发送数据报文了，但主动方仍可以接收数据报文。

​    （2）第二次挥手

​     被动方此时有可能还有相应的数据报文需要发送，因此需要先发送ACK报文，告知主动方“我知道你想断开连接的请求了”。这样主动方便不会因为没有收到应答而继续发送断开连接的请求（即FIN报文）。

   （3）第三次挥手

​    被动方在处理完数据报文后，便发送给主动方FIN报文；这样可以保证数据通信正常可靠地完成。发送完FIN报文后，被动方进入LAST_ACK阶段（超时等待）。

   （4）第四挥手

​    如果主动方及时发送ACK报文进行连接中断的确认，这时被动方就直接释放连接，进入可用状态。

扩展：当没有数据需要发送时是抓包发现是三次挥手。然而这是违反了网络分层的原则，下层不可依赖上层。



#### 3、TCP 初始序列号为什么是随机值？

这样做主要是出于网络安全的因素着想。如果不是随机产生初始序列号，而是固定的话，攻击者很容易猜出后续的确认号，然后伪造序列号进行攻击。



#### 4、为什么TCP4次挥手时等待为2MSL？

一方面是被动方没等到ACK就会重发FIN这需要2MSL(报文最大生存时间)，另一方面是让此次 TCP 连接中的所有报文在网络中消失。

假如现在 A 发送 ACK 后，最坏情况下，这个 ACK 在 1MSL 时到达 B；此时 B 在收到这个 ACK 的前一刹那，一直在重传 FIN，这个 FIN 最坏会在 1MSL 时间内消失。因此从 A 发送 ACK 的那一刹那开始，等待 2MSL 可以保证 A 发送的最后一个 ACK，和 B 发送的最后一个 FIN 都在网络中消失。



#### 5、TCP 中有哪些计时器

TCP有四种计时器，分别是：

1. 重传计时器：用于保证TCP数据可靠传输，当规定的时间没有收到对方的ACK就重发，以避免陷入无限等待中。
2. 持久计时器：当发送TCP收到窗口大小为0的确认时，就需要使用持久计时器，不定时去检测接收窗口大小是否更新。
3. 保活计时器：用来防止在两个TCP之间的连接出现长时间的空闲。
4. 时间等待计时器：在四次握手的时候使用的。

参考文章：[TCP超时与重传机制](https://www.cnblogs.com/duan2/p/9180861.html)



#### 6、DNS工作过程

1. 首先搜索浏览器的DNS缓存，缓存中维护一张域名与IP地址的对应表;
2. 若没有命中，则继续搜索操作系统的DNS缓存;
3. 若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器查询自己的DNS缓存，查找成功则返回结果(主机和本地域名服务器之间的查询方式是递归查询)；
4. 若本地域名服务器的DNS缓存没有命中，则本地域名服务器向上级域名服务器进行查询，通过以下方式进行迭代查询(本地域名服务器和其他域名服务器之间的查询方式是迭代查询，防止根域名服务器压力过大)；
5. 本地域名服务器将得到IP地址返回并缓存起来。



#### 7、TCP粘包、拆包及解决办法

假设 Client 向 Server 连续发送了两个数据包，用 packet1 和 packet2 来表示，那么服务端收到的数据可以分为三种情况，现列举如下：

第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象。

![img](pics\v2-1f03c5a6c04279d9c318ef48348dc32d_720w.png)

第二种情况，接收端只收到一个数据包，但是这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。

![img](pics\v2-e090a51ff37d6dfd1de747c70288222a_720w.png)

第三种情况，这种情况有两种表现形式，如下图。接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。

![img](pics\v2-6163805a4cbd6be0581cca82cd5ac8f5_720w.png)

![img](pics\v2-ca1d6c986cec845951dd0811f5888021_720w.png)

**为什么会发生 TCP 粘包、拆包？**

- 要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。
- 待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。
- 要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。
- 接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。

**粘包、拆包解决办法**

由于 TCP 本身是面向字节流的，无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，归纳如下：

- **消息定长：**发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
- **设置消息边界：**服务端从网络流中按消息边界分离出消息内容。在包尾增加回车换行符进行分割，例如 FTP 协议。
- **将消息分为消息头和消息体：**消息头中包含表示消息总长度（或者消息体长度）的字段。
- 更复杂的应用层协议比如 Netty 中实现的一些协议都对粘包、拆包做了很好的处理。



#### 8、说一说 HTTP 请求的过程

应用层：

- 浏览器封装HTTP请求报文
- DNS解析域名获得目标服务器地址

传输层：

- 建立连接
- 把应用层传过来的HTTP请求报文进行分割，并在各个报文上打上标记序号及端口号转发给网络层

网络层：

- 利用ARP协议根据IP地址获取作为通信目的地的MAC地址后转发给链路层


服务端在链路层收到数据，按序往上层发送，一直到应用层接收到浏览器发送来的HTTP请求报文然后处理该请求并返回HTTP响应报文，浏览器接收到响应报文之后解析渲染界面。最后TCP断开连接。

参考文章：[HTTP请求全过程](https://flying-veal.notion.site/04d85d0ae78f459aa9e92564ed7e7b26?v=1dcd3291193f4cb595c5cd7ef46b1341&p=8e300601270d4542a6f5a2077c91b9c8)



#### 9、HTTP 的缓存机制

浏览器存在一个缓存数据库,用于存储缓存信息。HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(强制缓存，对比缓存)。

对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。
对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。

参考文章：[HTTP缓存](https://www.cnblogs.com/chenqf/p/6386163.html)







