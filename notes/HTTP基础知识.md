## 1、HTTP协议版本变化

HTTP：超文本传输协议，是一个基于请求与响应，无状态的，应用层的协议。基于TCP/IP协议传输数据，互联网上应用最为广泛的一种网络协议,所有的WWW文件都必须遵守这个标准。[#参考文章](https://www.cnblogs.com/cckong/p/14117478.html)

### HTTP1.0

默认是**短连接**，每个TCP连接只能发送一个请求。发送数据完毕，连接就关闭，如果还要请求其他资源，就必须再新建一个连接。

缺点：如果需要请求很多资源的话，时间成本非常高。解决办法是设定`Connection: keep-alive`。

### HTTP1.1

开始默认是**长连接**，即TCP连接默认不关闭，可以被多个请求复用。如果要断开连接，需要由客户端或者服务器端提出断开，使用 `Connection : close`；

持久连接使得多数请求以**管道化（pipelining）**方式发送成为可能，即在同一个TCP连接里面，客户端可以同时发送多个请求。这样就进一步改进了HTTP协议的效率。

缺点：允许复用TCP连接，但是同一个TCP连接里面，所有的数据通信是按次序进行的。服务器只有处理完一个回应，才会进行下一个回应。要是前面的回应特别慢，后面就会有许多请求排队等着。这称为`队头堵塞`。这使得客户端需要使用多个连接才能实现并发和缩短延迟。

### HTTP2.0

（1）HTTP2.0 则是一个**彻底的二进制协议**，头信息和数据体都是二进制，并且统称为"帧"（frame）：头信息帧和数据帧。将每个请求或回应的所有数据包，称为一个数据流（stream）。每个数据流都有一个独一无二的编号。数据包发送的时候，都必须标记数据流ID，用来区分它属于哪个数据流。

（2）在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream），而且不用按照顺序一一对应，这样就避免了"队头堵塞"。举例来说，在一个TCP连接里面，服务器同时收到了A请求和B请求，于是先回应A请求，结果发现处理过程非常耗时，于是就发送A请求已经处理好的部分， 接着回应B请求，完成后，再发送A请求剩下的部分。

（3）服务器推送，允许服务器未经请求，主动向客户端发送资源

（4）首部压缩，HTTP/1.1 的首部带有大量信息，而且每次都要重复发送。HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。不仅如此，HTTP/2.0 也使用 Huffman 编码对首部字段进行压缩。

如下图图，这样双向的、实时的通信，这样并发多个流，就叫做多工（Multiplexing）

![http2.0](pics\http2.0.png)



## 2、HTTPS协议

HTTP有以下安全性问题：

- 通信使用明文（不加密），内容可能会被窃听
- 不验证通信方的身份，因此有可能遭遇伪装
- 无法证明报文的完整性，所以有可能遭到截取篡改

HTTPS 并不是新协议，只是HTTP通信接口部分用 SSL（Secure Sockets Layer）和TLS（Transport Layer Security，安全传输层协议）协议替代而已。

通常，HTTP直接和TCP通信。当使用SSL时，则演变成先和SSL通信，再由 SSL 和 TCP 通信了，也就是说 HTTPS 是使用了SSL隧道进行通信的HTTP。

通过使用 SSL，HTTPS 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。[#参考文章](https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#%E4%B8%83http20)

### 加密处理

#### 通信的加密

HTTP协议没有加密机制，但可以通过和SSL或TLS的组合使用，对整个通信线路加密处理，达到加密HTTP的通信内容。

#### 内容的加密

HTTPS采用的加密方式是基于密钥加密算法。

对称密钥加密方式的传输效率更高，但是无法安全地将密钥 Secret Key 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 Secret Key 传输给通信方。HTTPS 采用混合的加密机制，采用下面方案：

- 使用非对称密钥加密方式，传输对称密钥加密方式所需要的 Secret Key，从而保证安全性;
- 获取到 Secret Key 后，再使用对称密钥加密方式进行通信，从而保证效率。（下图中的 Session Key 就是 Secret Key）

![img](pics\https加密.png)

### 认证

HTTP协议中无法确定通信方，但是使用SSL则可以。通过使用 **证书** 来对通信方进行认证。

数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。

服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。

进行 HTTPS 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。

![img](pics\证书.png)

### 完整性保护

SSL 提供报文摘要功能来进行完整性保护。

HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。

HTTPS 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。

### HTTPS 的缺点

- 因为需要进行加密解密等过程，因此速度会更慢；
- 需要支付证书授权的高额费用。



## 3、HTTP请求与响应

客户端发送一个请求报文给服务器，服务器根据请求报文中的信息进行处理，并将处理结果放入响应报文中返回给客户端。

请求报文结构：

- 第一行是包含了请求方法、URL、协议版本；
- 接下来的多行都是请求首部 Header，每个首部都有一个首部名称，以及对应的值。
- 一个空行用来分隔首部和内容主体 Body
- 最后是请求的内容主体

```txt
GET http://www.example.com/ HTTP/1.1
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
Cache-Control: max-age=0
Host: www.example.com
If-Modified-Since: Thu, 17 Oct 2019 07:18:26 GMT
If-None-Match: "3147526947+gzip"
Proxy-Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 xxx

param1=1&param2=2
```

响应报文结构：

- 第一行包含协议版本、状态码以及描述，最常见的是 200 OK 表示请求成功了
- 接下来多行也是首部内容
- 一个空行分隔首部和内容主体
- 最后是响应的内容主体

```txt
HTTP/1.1 200 OK
Age: 529651
Cache-Control: max-age=604800
Connection: keep-alive
Content-Encoding: gzip
Content-Length: 648
Content-Type: text/html; charset=UTF-8
Date: Mon, 02 Nov 2020 17:53:39 GMT
Etag: "3147526947+ident+gzip"
Expires: Mon, 09 Nov 2020 17:53:39 GMT
Keep-Alive: timeout=4
Last-Modified: Thu, 17 Oct 2019 07:18:26 GMT
Proxy-Connection: keep-alive
Server: ECS (sjc/16DF)
Vary: Accept-Encoding
X-Cache: HIT

<!doctype html>
<html>
<head>
    <title>Example Domain</title>
	// 省略... 
</body>
</html>
```

HTTP请求，最初设定了八种方法。这八种方法本质上没有任何区别。只是让请求更加有语义而已。

- OPTIONS 返回服务器所支持的请求方法
- GET 向服务器获取指定资源
- HEAD 与GET一致，只不过响应体不返回，只返回响应头
- POST 向服务器提交数据，数据放在请求体里
- PUT 与POST相似，只是具有幂等特性，一般用于更新
- DELETE 删除服务器指定资源
- TRACE 回显服务器端收到的请求，测试的时候会用到这个
- CONNECT 预留，暂无使用



**GET 和 POST 比较：**

- 作用：GET 用于获取资源，而 POST 用于传输实体主体；
- 参数：GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中；
- 安全：安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变；
- 幂等性：幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。GET方法是幂等的，POST是非幂等的。
- 可缓存：GET方法对响应进行缓存，而POST方法多数情况下不可缓存的。

此外，HTTP的底层是TCP/IP。所以GET和POST的底层也是TCP/IP，所以GET和POST能做的事情是一样一样的。你要给GET加上request body，给POST带上url参数，技术上是完全行的通的。



## 4、密钥加密技术

#### 对称密钥

对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。代表算法DES、AES [#参考文章](https://www.cnblogs.com/shoshana-kong/p/10934550.html)

- 优点：运算速度快；
- 缺点：无法安全地将密钥传输给通信方。

![img](pics\对称加密.png)

#### 非对称密钥加密

非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。代表算法RSA

公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。

**非对称密钥除了用来加密，还可以用来进行签名**。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。

- 优点：可以更安全地将公开密钥传输给通信发送方；
- 缺点：运算速度慢，以及无法证明公开密钥本身就是货真价实的公开密钥。

![img](pics\非对称加密.png)

对于加密后的信息，想要根据密文和公开密钥，恢复到信息原文是异常困难的，因为解密过程就是在对离散对数进行求值，这本非轻而易举就能办到。退一步讲，如果能对一个非常大的整数做到快速地因式分解，那么密码破解还是存在希望地。但就目前的技术来看是不太现实的。

**加密与签名：**

公钥和私钥都是密钥，被公开的那个就是公钥，没有被公开的那个就是私钥。

公钥和私钥都可以用于加解密操作，用公钥加密的数据只能由对应的私钥解密，反之亦然。虽说两者都可用于加密，但是不同场景使用不同的密钥来加密，规则如下：

- 私钥用于签名、公钥用于验签

签名和加密作用不同，签名并不是为了保密，而是为了保证这个签名是由特定的某个人签名的，而不是被其它人伪造的签名，所以私钥的私有性就适合用在签名用途上。

私钥签名后，只能由对应的公钥解密，公钥又是公开的（很多人可持有），所以这些人拿着公钥来解密，解密成功后就能判断出是持有私钥的人做的签名，验证了身份合法性。

- 公钥用于加密、私钥用于解密，这才能起到加密作用

因为公钥是公开的，很多人可以持有公钥。若用私钥加密，那所有持有公钥的人都可以进行解密，这是不安全的！

若用公钥加密，那只能由私钥解密，而私钥是私有不公开的，只能由特定的私钥持有人解密，保证的数据的安全性。



## 5、HTTPS的数字证书验证原理

数字证书是HTTPS实现安全传输的基础，它是由权威的CA机构颁发的，证书的主要内容有：公钥（Public Key）、ISSUER（证书的发布机构）、Subject（证书持有者）、证书有效期、签名算法、指纹及指纹算法等。[#参考文章](https://blog.csdn.net/liuxingrong666/article/details/83869161)

![image-20220112170322860](pics\证书图片.png)

CA机构除了给别人颁发证书以外，它也有自己的证书，这个证书是机构自己颁发给自己的，为了区分我们称它为根证书，**根证书也有自己的公钥和私钥，在本文中我们称之为根公钥和根私钥，根公钥和加密算法是对外公布的，而根私钥是CA机构自己绝对保密的。**这个根证书在验证证书的过程中起着核心的作用。一般这些权威机构的根证书都是浏览器预先嵌入到浏览器系统中的。

### 证书的指纹和签名

在解析数字证书的验证之前，先来解析一下什么是指纹和数字签名？

如上图证书中可以找到一个叫指纹的字符串，指纹可以理解为证书身份的唯一代表，是用来保证证书的完整性的，确保证书没有被修改过。证书在发布之前，CA机构对证书的内容用指纹算法（一般是sha1或sha256）计算得到一个hash值，这个hash值就是指纹。

为什么用hash值作为证书的身份代表呢？首先，**hash值具有不可逆性**，也就是说无法通过hash值得出原来的信息内容；其次，hash值具有唯一性，即hash计算可以保证不同的内容一定得到不同的hash值。

**数字签名是在信息后面加上的一段数字串，可以证明该信息有没有被修改过。**数字证书在发布的时候，CA机构将证书的指纹和指纹算法通过自己的私钥加密得到的就是证书的签名了。

### 证书的验证

我们在验证证书的时候，首先通过机构的根公钥去解密证书的签名，解密成功的话会得到证书的指纹和指纹算法，指纹是一个hash值，它代表着证书的原始内容，此时再通过指纹算法计算证书内容得到另外一个hash值，如果这两个hash值相同，则代表证书没有被篡改过，否则就是被篡改了。
![image-20220112172603172](pics\数字签名.png)

假设这是一个浏览器的HTTPS请求：

一：首先浏览器通过URL网址去请求服务端，服务端接收到请求后，就会给浏览器发送一个自己的CA数字证书

二：浏览器接收到证书以后，就要开始进行验证工作了。首先从证书中得知证书的颁发机构，然后从浏览器系统中去寻找此颁发机构的根证书。上面我们也看到，世界上权威CA机构的根证书都是预先嵌入到浏览器中的，如果在浏览器系中没有找到对应的根证书，就代表此机构不是受信任的，那么就会警告无法确认证书的真假。

如果我们找到了证书颁发机构的根证书，那么就从根证书中取得那个根公钥，用根公钥去解密此证书的数字签名，成功解密的话就得到证书的指纹和指纹算法，指纹是证书内容通过指纹算法计算得到的一个hash值，这里我们称之为h1，h1代表证书的原始内容；然后用指纹算法对当前接收到的证书内容再进行一次hash计算得到另一个值h2，h2则代表当前证书的内容，如果此时h1和h2是相等的，就代表证书没有被修改过。如果证书被篡改过，h2和h1是不可能相同的，因为hash值具有唯一性，不同内容通过hash计算得到的值是不可能相同的。
有人说假如证书上的指纹是不法分子伪造的，伪造是没有用的，因为你伪造的指纹不可能用CA机构的根私钥去加密（根私钥是CA机构绝对保密的），伪造者只能拿自己的秘钥去加密这个伪造的指纹，但当我们拿机构的根公钥去解密伪造指纹的时候是不可能成功的（加密内容只能由一对公钥私钥解密）

在证书没有被修改过的基础上，再检查证书上的使用者的URL（比如csdn.net）和我们请求的URL是否相等，如果相等，那么就可以证明当前浏览器链接的网址也是正确的，而不是一些钓鱼网之类的

但如果浏览器的连接被某个中间人截取了，中间人也可以发一个由权威的CA机构颁发的证书给浏览器，然后也可以通过证书没有被篡改的验证，但是在证书没有被篡改的前提下，通过对比证书上的URL和我们请求的URL是否相同，我们还是可以判断当前证书是不是服务器发的证书。可以这么理解，因为URL具有唯一性，所以中间人的证书的上的URL和我们的证书的URL是不可能相同的，如果中间人修改了自己证书上的URL，那么就通过不了证书没有被篡改的验证，所以中间人的证书也是欺骗不了我们的

到这里我们认证了三点信息：

1.证书是否为受信任的权威机构颁发的

2.证书是否被篡改

3.证书是否为服务器发过来的，而不是第三方发的

三：基于上面的三点信息认证都没有问题的情况下，下一步我们有一个重要的任务就是，如何将一个对称加密算法的秘钥安全地发给服务器

首先随机生成一个字符串S作为我们的秘钥，然后通过证书中服务器公钥加密成密文，将密文发送给服务器。因为此密文是用公钥加密的，这是一个非对称加密，我们知道，这个密文只有私钥的持有者才能进行解密，在这里私钥的持有者当然是服务器了，所以说任何第三方截取到密文也是没用的，因为没有对应的私钥无法解密得到我们的密文

还有一个关键步骤，发送密文的时候也会对消息内容进行签名操作。签名上面讲解过，就是对密文内容进行hash计算得到的hash值再通过公钥或私钥加密得到的一段数字串，这个签名和消息内容一起发送出去。接收方收到消息以后，通过私钥或公钥解析出密文和签名的hash值，同时也会对接收的消息内容进行同样的hash计算得到另一个hash值，比对两个hash值是否相同来判断消息有没有被篡改过。

四：通过了上面的步骤以后，此时客户端和服务端都持有了对称加密算法的同一个秘钥，然后两者就可以安全通信。

**数字证书的验证有两个重要的步骤：**

- 第一是客户端验证服务器发的数字证书有没有被篡改，以及没有被篡改的证书是否为服务器发的证书，而不是任何第三方假冒服务器发的证书；
- 第二是客户端将对称加密算法的秘钥安全地发送给服务器。这两步都完成以后，整个HTTPS的数字证书的验证就算是成功了



