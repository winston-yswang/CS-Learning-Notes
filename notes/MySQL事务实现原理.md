## 一、数据库事务

数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：**要么全部执行成功,要么全部不执行** 。

### 1、何为 ACID 特性

关系型数据库（例如：`MySQL`、`SQL Server`、`Oracle` 等）事务都有 **ACID** 特性：

![事务的特性](C:/Users/Lenovo/Desktop/笔记/CS-Learning-Notes/notes/pics/事务特性.png)

1. **原子性**（`Atomicity`） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；
2. **一致性**（`Consistency`）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；
3. **隔离性**（`Isolation`）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；
4. **持久性**（`Durability`）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。

综上，其实事务主要是满足可靠性以及并发处理两大特点。[#参考文章](https://blog.csdn.net/weixin_39660931/article/details/113436934)

可靠性：数据库要保证当insert或update操作时抛异常或者数据库crash的时候需要保障数据的操作前后的一致。为此，MySQL InnoDB 引擎使用 **redo log(重做日志)** 保证事务的**持久性**，使用 **undo log(回滚日志)** 来保证事务的**原子性**。

并发处理：也就是说当多个并发请求过来，并且其中有一个请求是对数据修改操作的时候会有影响，为了避免读到脏数据，所以需要对事务之间的读写进行隔离。为此，MySQL InnoDB 引擎通过 **锁机制**、**MVCC** 等手段来保证事务的隔离性（ 默认支持的隔离级别是 **`REPEATABLE-READ`** ）。

保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。

### 2、并发事务带来的问题

在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。

- **脏读（Dirty read）:** 指当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。
- **丢失修改（Lost to modify）:** 指两个事务同时读取了一个数据并做修改，那么其中一个事务的修改结果则会被丢失，称为丢失修改。 例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。
- **不可重复读（Unrepeatable read）:** 在一个事务开启过程中，当前事务读取到了另一事务提交的修改，导致在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
- **幻读（Phantom read）:** 幻读与不可重复读类似。在一个事务开启过程中，读取到另一个事务提交导致的数据条目的新增或删除，导致在一个事务内两次读到的数据条数不一致，所以称为幻读。

**不可重复读和幻读区别：**

不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。

### 3、事务的隔离级别

**READ-UNCOMMITTED(读未提交)**：如果一个事务读到了另一个未提交事务修改过的数据，那么这种隔离级别就称为未提交读。

**READ-COMMITTED(读已提交)：** 如果一个事务只能读到另一个已经提交的事务修改过的数据，并且其他事务每对该数据进行一次修改并提交后，该事务都能查询得到最新值，那么这种隔离级别就称为已提交读。可以阻止脏读，但仍然可能发生不可重复读和幻读。

**REPEATABLE-READ(可重复读取)：** 一个事务对同一字段的多次读取结果都是一致的，即使期间其他事务修改了该记录的值并且提交，该事务再次读取时，读到的仍是第一次读到的值，而不是每次读到不同的数据。那么这种隔离级别就称为可重复读。可以阻止脏读和不可重复读，但幻读仍有可能发生。

**SERIALIZABLE(可串行化)：** 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。



## 二、redo log 与 undo log介绍

### 1、redo log

#### 什么是 redo log？

`redo log`叫做重做日志，是用来实现事务的持久性。该日志文件由两部分组成：重做日志缓冲(redo log buffer)以及重做日志文件(redo log),前者是在内存中，后者在磁盘中。当事务提交之后会把所有修改信息都会存到该日志中。

![redolog](pics\redolog.png)

#### redo log有什么用？

mysql 为了提升性能不会把每次的修改都实时同步到磁盘，而是会先存到Boffer Pool(缓冲池)里头，把这个当作缓存来用。然后使用后台线程去做缓冲池和磁盘之间的同步。

如果还没来的同步的时候宕机或断电了怎么办？这样会导致丢部分已提交事务的修改信息！

所以引入了`redo log`来记录已成功提交事务的修改信息，并且会把`redo log`持久化到磁盘，系统重启之后在读取`redo log`恢复最新数据。

总结：`redo log`是用来恢复数据的，用于保障已提交事务的持久化特性。

### 2、undo log

#### 什么是undo log？

`undo log` 叫做回滚日志，用于记录数据被修改前的信息，每条数据变更(insert/update/delete)操作都伴随一条`undo log`的生成,并且回滚日志必须先于数据持久化到磁盘上。

#### undo log有什么用？

为了做到同时成功或者失败，当系统发生错误或者执行rollback操作时需要根据undo log 进行回滚，而回滚则是根据`undo log`做逆向操作，把数据还原到没被修改前的状态。

总结：`undo log`是用来回滚数据的，用于保障未提交事务的原子性。



## 三、MySQL锁技术以及MVCC基础

### 1、MySQL锁技术

当有多个请求来读取表中的数据时可以不采取任何操作，但是多个请求里既有读请求又有写请求时，就必须有一种措施来进行并发控制，否则有可能造成不一致。

解决上述问题只需要两种锁的组合来对读写请求进行控制即可，分别是：

共享锁（shared lock）：也叫读锁，多个读请求可以共享一把锁读数据，不会造成阻塞；

排他锁（exclusive lock）：也叫写锁，写锁会排斥其他所有获取锁的请求，一直阻塞，直到写入完成释放锁。

总结：通过读写锁，可以做到读读并行，但是不能做到读写、写写并行。

### 2、MVCC基础

MVCC（Multi-Version Concurrency Control ，多版本并发控制）就是一种并发控制的方法，主要实现思想是通过数据多版本来做到读写分离。从而实现不加锁读进而做到读写并行。

MVCC在MySQL中的实现依赖的是`undo log`与`read view`。

#### 版本链

对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列（`row_id`并不是必要的，我们创建的表中有主键或者非NULL唯一键时都不会包含`row_id`列）：

- `trx_id` ：事务ID，记录创建这条记录/最后一次修改该记录的事务ID；

- `roll_pointer` ：回滚指针，指向这条记录的上一个版本。

每次对记录进行改动，都会记录一条`undo日志`，每条`undo日志`也都有一个`roll_pointer`属性（`INSERT`操作对应的`undo日志`没有该属性，因为该记录并没有更早的版本），可以将这些`undo日志`都连起来，串成一个链表。

对该记录每次更新后，都会将旧值放到一条`undo日志`中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被`roll_pointer`属性连接成一个链表，我们把这个链表称之为`版本链`，版本链的头节点就是当前记录最新的值。

<img src="C:/Users/Lenovo/Desktop/笔记/CS-Learning-Notes/notes/pics/a7fad862d80f184f1f117d93cd9090ba.png" alt="img" style="zoom:50%;" />

#### Read View（读视图）

`Read View`是事务进行快照读操作的时候生产的读视图(Read View)，在该事务执行的快照读的那一刻，会生成数据库系统当前的一个快照，**记录并维护系统当前活跃事务的ID**(当每个事务开启时，都会被分配一个ID, 这个ID是递增的，所以最新的事务，ID值越大)

对于使用`READ UNCOMMITTED`隔离级别的事务来说，直接读取记录的最新版本就好了，对于使用`SERIALIZABLE`隔离级别的事务来说，使用加锁的方式来访问记录。对于使用`READ COMMITTED`和`REPEATABLE READ`隔离级别的事务来说，就需要用到我们上边所说的`版本链`了，核心问题就是：需要判断一下版本链中的哪个版本是当前事务可见的。所以设计`InnoDB`的大叔提出了一个`ReadView`的概念，这个`ReadView`中主要包含当前系统中还有哪些活跃的读写事务，把它们的事务id放到一个列表中，我们把这个列表命名为为`m_ids`。这样在访问某条记录时，只需要按照下边的步骤判断记录的某个版本是否可见：

- 如果被访问版本的`trx_id`属性值小于`m_ids`列表中最小的事务id，表明生成该版本的事务在生成`ReadView`前已经提交，所以该版本可以被当前事务访问。
- 如果被访问版本的`trx_id`属性值大于`m_ids`列表中最大的事务id，表明生成该版本的事务在生成`ReadView`后才生成，所以该版本不可以被当前事务访问。
- 如果被访问版本的`trx_id`属性值在`m_ids`列表中最大的事务id和最小事务id之间，那就需要判断一下`trx_id`属性值是不是在`m_ids`列表中，如果在，说明创建`ReadView`时生成该版本的事务还是活跃的，该版本不可以被访问；如果不在，说明创建`ReadView`时生成该版本的事务已经被提交，该版本可以被访问。

如果某个版本的数据对当前事务不可见的话，那就顺着版本链找到下一个版本的数据，继续按照上边的步骤判断可见性，依此类推，直到版本链中的最后一个版本，如果最后一个版本也不可见的话，那么就意味着该条记录对该事务不可见，查询结果就不包含该记录。

在`MySQL`中，`READ COMMITTED`和`REPEATABLE READ`隔离级别的的一个非常大的区别就是它们生成`ReadView`的时机不同。

- `READ COMMITTED` --- 每次读取数据前都生成一个ReadView
- `REPEATABLE READ` --- 只在第一次读取数据时生成一个ReadView

#### 可重复读隔离级别的不可重复读和幻读问题

对于正常的 select 查询 innodb 实际上进行的是快照读，即通过判断读取到的行的 DB_TRX_ID 与 DB_ROLL_PTR 字段指向的 undo log 回溯到事务开启前或当前事务最后一次更新的数据版本，从而在这样的场景下避免了可重复读与幻读的问题。

**针对已存在的数据**，insert 和 update 操作虽然是进行当前读，但 insert 与 update 操作后，该行的最新修改事务 ID 为当前事务 ID，因此读到的值仍然是当前事务所修改的数据，不会产生不可重复读的问题。

但如果当前事务**更新到了其他事务新插入并提交了的数据**，这就会造成该行数据的 DB_TRX_ID 被更新为当前事务 ID，此后即便进行快照读，依然会查出该行数据，产生幻读（其他事务插入或删除但未提交该行数据的情况下会锁定该行，造成当前事务对该行的更新操作被阻塞，所以这种情况不会产生幻读问题）

我们实际来看一个例子。首先，我们创建一个表：

```sql
CREATE TABLE `test` (
  `id` int(10) unsigned NOT NULL AUTO_INCREMENT,
  `value` int(10) unsigned NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8
```

然后我们插入三条初始数据：

```sql
INSERT INTO `test` (`value`) VALUES (1), (2), (3)
```

接下来我们在两个窗口中分别开启一个事务并查询出现有数据：

![](C:/Users/Lenovo/Desktop/笔记/CS-Learning-Notes/notes/pics/0c9f470819684156cfdc27c682db4def.png)

我们在其中一个事务中先更新 id 为 1 的数据，再插入一条 id 为 4 的数据，再删除 id 为 2 的数据，然后，在另一个事务中查询，可以看到此时查询出来的仍然是事务开启时的初始数据，说明当前隔离级别和场景下并没有脏读的问题存在：

![](C:/Users/Lenovo/Desktop/笔记/CS-Learning-Notes/notes/pics/20190911224236136.png)

此时，我们提交所有的修改，接着在另一个事务中查询，可以看到此时查询到的结果仍然是事务开启前的原始数据，说明当前隔离级别和场景下并没有不可重复读和幻读的问题存在：

![](C:/Users/Lenovo/Desktop/笔记/CS-Learning-Notes/notes/pics/2019091122425048.png)

那么接下来，我们在未提交的这个事务中执行一条修改，可以看到，本应在事务中只影响一行的 update 操作返回了 changed: 2，接着，我们查询结果出现了 id 为 4 的行，**说明了幻读问题的存在【update当前读会读最新数据】**：

![](C:/Users/Lenovo/Desktop/笔记/CS-Learning-Notes/notes/pics/20190911224305759.png)

上面的实验可见，可重复读隔离级别并没有完全解决幻读问题。



综上总结，实现事务采取的技术以及思想：

原子性：使用 undo log ，从而达到回滚；

持久性：使用 redo log，从而达到故障后恢复；

隔离性：使用锁以及MVCC,运用的优化思想有读写分离，读读并行，读写并行。

一致性：通过回滚，以及恢复，和在并发环境下的隔离做到一致性。











